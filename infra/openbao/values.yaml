server:
  ha:
    enabled: true
    replicas: 3
    config: |
      storage "postgresql" {
        connection_url = "postgresql://admin:admin@postgres-cluster-rw.postgres.svc.cluster.local:5432/openbao_db?sslmode=disable"
        ha_enabled = "true"
      }

      listener "tcp" {
        address     = "0.0.0.0:8200"
        tls_disable = 1
      }

      seal "transit" {
        address = "http://openbao-transit:8200"
        disable_renewal = "false"
        key_name = "autounseal"
        mount_path = "transit/"
      }

      api_addr = "http://$(POD_IP):8200"
      cluster_addr = "https://$(POD_IP):8201"

      ui = true

      service_registration "kubernetes" {}

  # Init container: authenticate to transit OpenBao via Kubernetes auth,
  # obtain a token, and create/update a Kubernetes Secret for the main container.
  # Uses curlimages/curl which has curl + sh. Talks to K8s API directly (no kubectl needed).
  extraInitContainers:
    - name: transit-auth
      image: curlimages/curl:latest
      command:
        - /bin/sh
        - -ec
        - |
          # Wait for transit OpenBao to be ready
          until curl -sf http://openbao-transit.openbao.svc:8200/v1/sys/health > /dev/null 2>&1; do
            echo "Waiting for transit OpenBao to be ready..."
            sleep 2
          done
          echo "Transit OpenBao is ready"

          # Read the ServiceAccount JWT token
          KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
          NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
          CA_CERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt

          # Authenticate to transit OpenBao using Kubernetes auth method
          RESPONSE=$(curl -sf -X POST \
            -H "Content-Type: application/json" \
            -d "{\"role\":\"autounseal\",\"jwt\":\"${KUBE_TOKEN}\"}" \
            http://openbao-transit.openbao.svc:8200/v1/auth/kubernetes/login)

          # Extract the client token from the JSON response using sed
          TRANSIT_TOKEN=$(echo "${RESPONSE}" | sed 's/.*"client_token":"\([^"]*\)".*/\1/')

          if [ -z "${TRANSIT_TOKEN}" ] || [ "${TRANSIT_TOKEN}" = "${RESPONSE}" ]; then
            echo "ERROR: Failed to obtain transit token"
            echo "Response: ${RESPONSE}"
            exit 1
          fi
          echo "Successfully obtained transit token via Kubernetes auth"

          # Base64 encode the token for the K8s Secret
          TOKEN_B64=$(echo -n "${TRANSIT_TOKEN}" | base64)

          # Create or update the Kubernetes Secret via the K8s API directly
          SECRET_JSON="{
            \"apiVersion\": \"v1\",
            \"kind\": \"Secret\",
            \"metadata\": {
              \"name\": \"openbao-transit-token\",
              \"namespace\": \"${NAMESPACE}\"
            },
            \"type\": \"Opaque\",
            \"data\": {
              \"token\": \"${TOKEN_B64}\"
            }
          }"

          # Try PUT (update) first, fall back to POST (create)
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --cacert "${CA_CERT}" \
            -H "Authorization: Bearer ${KUBE_TOKEN}" \
            -H "Content-Type: application/json" \
            -X PUT \
            -d "${SECRET_JSON}" \
            "https://kubernetes.default.svc/api/v1/namespaces/${NAMESPACE}/secrets/openbao-transit-token")

          if [ "${HTTP_CODE}" = "404" ]; then
            echo "Secret does not exist yet, creating..."
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              --cacert "${CA_CERT}" \
              -H "Authorization: Bearer ${KUBE_TOKEN}" \
              -H "Content-Type: application/json" \
              -X POST \
              -d "${SECRET_JSON}" \
              "https://kubernetes.default.svc/api/v1/namespaces/${NAMESPACE}/secrets")
          fi

          if [ "${HTTP_CODE}" -ge 200 ] && [ "${HTTP_CODE}" -lt 300 ]; then
            echo "Transit token secret created/updated successfully (HTTP ${HTTP_CODE})"
          else
            echo "ERROR: Failed to create/update secret (HTTP ${HTTP_CODE})"
            exit 1
          fi

  # Sidecar container: auto-initialize OpenBao if not yet initialized.
  # Runs once on startup, stores recovery key + root token in a K8s Secret, then exits.
  extraContainers:
    - name: auto-init
      image: curlimages/curl:latest
      command:
        - /bin/sh
        - -ec
        - |
          # Wait for the local OpenBao server to be responding
          echo "Waiting for OpenBao to start..."
          until curl -sf -o /dev/null http://127.0.0.1:8200/v1/sys/health?standbyok=true\&uninitcode=200\&sealedcode=200 2>/dev/null; do
            sleep 2
          done
          echo "OpenBao is responding"

          # Check if already initialized
          HEALTH=$(curl -s http://127.0.0.1:8200/v1/sys/health)
          INITIALIZED=$(echo "${HEALTH}" | sed 's/.*"initialized":\([a-z]*\).*/\1/')

          if [ "${INITIALIZED}" = "true" ]; then
            echo "OpenBao is already initialized. Nothing to do."
            exit 0
          fi

          echo "OpenBao is NOT initialized. Running auto-init..."

          # Initialize with transit auto-unseal (use recovery keys, not unseal keys)
          INIT_RESPONSE=$(curl -sf -X PUT \
            -H "Content-Type: application/json" \
            -d '{"recovery_shares": 1, "recovery_threshold": 1}' \
            http://127.0.0.1:8200/v1/sys/init)

          # Extract root token and recovery key
          ROOT_TOKEN=$(echo "${INIT_RESPONSE}" | sed 's/.*"root_token":"\([^"]*\)".*/\1/')
          RECOVERY_KEY=$(echo "${INIT_RESPONSE}" | sed 's/.*"recovery_keys_base64":\["\([^"]*\)".*/\1/')

          if [ -z "${ROOT_TOKEN}" ] || [ "${ROOT_TOKEN}" = "${INIT_RESPONSE}" ]; then
            echo "ERROR: Failed to initialize OpenBao"
            echo "Response: ${INIT_RESPONSE}"
            exit 1
          fi

          echo "OpenBao initialized successfully"

          # Store credentials in a Kubernetes Secret
          KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
          NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
          CA_CERT=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt

          ROOT_TOKEN_B64=$(echo -n "${ROOT_TOKEN}" | base64)
          RECOVERY_KEY_B64=$(echo -n "${RECOVERY_KEY}" | base64)

          SECRET_JSON="{
            \"apiVersion\": \"v1\",
            \"kind\": \"Secret\",
            \"metadata\": {
              \"name\": \"openbao-init-credentials\",
              \"namespace\": \"${NAMESPACE}\"
            },
            \"type\": \"Opaque\",
            \"data\": {
              \"root-token\": \"${ROOT_TOKEN_B64}\",
              \"recovery-key\": \"${RECOVERY_KEY_B64}\"
            }
          }"

          # Try PUT first, fall back to POST
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --cacert "${CA_CERT}" \
            -H "Authorization: Bearer ${KUBE_TOKEN}" \
            -H "Content-Type: application/json" \
            -X PUT \
            -d "${SECRET_JSON}" \
            "https://kubernetes.default.svc/api/v1/namespaces/${NAMESPACE}/secrets/openbao-init-credentials")

          if [ "${HTTP_CODE}" = "404" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              --cacert "${CA_CERT}" \
              -H "Authorization: Bearer ${KUBE_TOKEN}" \
              -H "Content-Type: application/json" \
              -X POST \
              -d "${SECRET_JSON}" \
              "https://kubernetes.default.svc/api/v1/namespaces/${NAMESPACE}/secrets")
          fi

          if [ "${HTTP_CODE}" -ge 200 ] && [ "${HTTP_CODE}" -lt 300 ]; then
            echo "Init credentials stored in secret 'openbao-init-credentials' (HTTP ${HTTP_CODE})"
          else
            echo "WARNING: Failed to store credentials in K8s secret (HTTP ${HTTP_CODE})"
            echo "Root Token: ${ROOT_TOKEN}"
            echo "Recovery Key: ${RECOVERY_KEY}"
          fi

  dataStorage:
    enabled: false

  standalone:
    enabled: false

  auditStorage:
    enabled: true
    size: 1Gi

  ui:
    enabled: true

  resources:
    requests:
      memory: 256Mi
      cpu: 250m
    limits:
      memory: 512Mi
      cpu: 500m

  # Use extraArgs to source the transit token as VAULT_TOKEN before starting
  # The extraArgs value is appended to the shell script that runs in /bin/sh -ec

  extraSecretEnvironmentVars:
    - envName: VAULT_TOKEN
      secretName: openbao-transit-token
      secretKey: token
    - envName: PGHOST
      secretName: openbao-postgres-secret
      secretKey: PGHOST
    - envName: PGPORT
      secretName: openbao-postgres-secret
      secretKey: PGPORT
    - envName: PGUSER
      secretName: openbao-postgres-secret
      secretKey: PGUSER
    - envName: PGPASSWORD
      secretName: openbao-postgres-secret
      secretKey: PGPASSWORD
    - envName: OPENBAO_DB
      secretName: openbao-postgres-secret
      secretKey: OPENBAO_DB

injector:
  enabled: true
  replicas: 2
  resources:
    requests:
      memory: 128Mi
      cpu: 100m
    limits:
      memory: 256Mi
      cpu: 200m

global:
  enabled: true
  tlsDisable: true

podDisruptionBudget:
  enabled: true
  maxUnavailable: 1